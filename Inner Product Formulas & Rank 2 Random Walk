import numpy as np
import scipy.linalg as sp
import gaussian 
import timeit
from pfaffian import pfaffian as Pf
import scipy.sparse

n = 4
rank = 1

Omega0 = np.block([[np.zeros((n,n)),np.eye(n)],[-np.eye(n),np.zeros((n,n))]])
J0 = Omega0 
I = np.eye(2*n)

# Takes the Cartan decomposition of a matrix. Verified.
def cartan(M):
    T = sp.sqrtm(-Omega0 @ M.T @ Omega0 @ M)
    u = T @ np.linalg.inv(M)
    theta = -0.25 * np.trace(Omega0 @ sp.logm(u))
    return [T,u,theta]

# Kronecker delta 
def delta(a,b):
    if a==b:
        return 1
    else:
        return 0

# Converts a matrix to its complex counterpart. Verified.
def cMatrix(K):
    K1 = K[0:n,0:n]
    K2 = K[0:n,n:2*n]
    return K1 + 1j * K2

# Takes the complex determinant of a matrix. Verified
def cDet(K):
    return np.linalg.det(cMatrix(K))

# Executes Equation (82) in the draft paper. Verified.
def ip(M1,M2):
    deltaM = np.linalg.inv(M1) @ M2
    return np.sqrt(cDet((deltaM - (J0 @ deltaM @ J0))/2))

# Varies Omega randomly. The larger the value of epsilon, the larger the variation.
def vary(Omega,epsilon):
    K = np.random.rand(2*n,2*n)
    K = K - K.T 
    return sp.expm(epsilon*K) @ Omega @ sp.expm(epsilon*K.T)

# Calculates the matrix A+ defined by Equation (C26)
def APlus(T):
    a = 0.5*sp.tanhm(sp.logm(T))
    return a[0:n,0:n] + 1j * a[0:n,n:2*n]

# Calculates the matrix R in Equation (C29)
def R(T):
    APC = np.conjugate(APlus(T))
    iden = np.eye(n)
    return np.block([[iden-APC,-1j*APC],[-1j*APC,iden+APC]])

# Executes Equation (C31)
def r0(T,theta):
    AP = APlus(T)
    return sp.expm(-1j*theta-np.trace(A0(AP)))

# The 2-point function of a Gaussian state
def C2(M):
    return 0.5*(I + 1j*M)

# Wick's theorem for 4-point functions
def wicks4(C,a,b,c,d):
    return C[a,b]*C[c,d] - C[a,c]*C[b,d] + C[a,d]*C[b,c]

# Building blocks of generalised Wick's theorem for quadratic terms. Verified. 
def buildingBlock2(M,a,b):
    decomp = cartan(M)
    T = decomp[0]
    theta = decomp[2]
    R1 = R(T)
    result = 0
    for i in range(2*n):
        for j in range(2*n):
            result += R1[a,i] * R1[b,j] * Omega0[i,j]
    return 1j*0.5 * r0(T,theta)*result


# Building blocks of generalised Wick's theorem for quartic terms. Verified. 
def buildingBlock4(M,a,b,c,d):
    decomp = cartan(M)
    T = decomp[0]
    theta = decomp[2]
    R1 = R(T)
    result = 0
    for i in range(2*n):
        for j in range(2*n):
            for k in range(2*n):
                for l in range(2*n):
                    result += R1[a,i] * R1[b,j] * R1[c,k] * R1[d,l] * vacuumCorrelator[i,j,k,l]
    return r0(T,theta) * result


space = gaussian.FermionicSpace(n)

# Represents a Lie algebra element in Hilbert space
def hat(X):
    Xhat = np.zeros((space.dimension,space.dimension),dtype="complex_")
    for i in range(2*n):
        for j in range(2*n):
            Xhat += 0.5*X[i,j] * space.majorana[i] @ space.majorana[j]
    return Xhat 

# Equation (C24). Verified. 
def Q(K):
    KPlus = 0.5*(K[0:n,0:n] + 1j * K[0:n,n:2*n])
    result = np.zeros((space.dimension,space.dimension),dtype="complex_")
    for i in range(n):
        for j in range(n):
            result += KPlus[i,j]*space.raising[i]@space.raising[j] + np.conjugate(KPlus[i,j])*space.lowering[i]@space.lowering[j]
    return result 

def A0(AP):
    return 0.25*sp.logm(np.eye(n) - 4 * AP @ np.conjugate(AP))

def expQ(K):
    AP = APlus(sp.expm(K))
    Azero = A0(AP)
    firstterm = np.zeros((space.dimension,space.dimension),dtype="complex_")
    secondterm = firstterm.copy()
    thirdterm = firstterm.copy()
    for k in range(n):
        for l in range(n):
            firstterm += AP[k,l]*space.raising[k] @ space.raising[l]
            secondterm += Azero[k,l] * space.raising[k] @ space.lowering[l] - Azero[l,k]*space.lowering[k]@space.raising[l]
            thirdterm += np.conjugate(AP)[k,l]*space.lowering[k]@space.lowering[l]
    return sp.expm(firstterm) @ sp.expm(secondterm) @ sp.expm(thirdterm)

# Gaussian unitary of a group element connected to identity
def U(g):
    return sp.expm(hat(sp.logm(g)))

def Udag(g):
    return U(np.linalg.inv(g))

# This is the reference state |J0> = |0>
vacuum = np.zeros((2**n,1),dtype="complex_")
vacuum[0,0] = 1


# The T- term in Equation (35). Verified.
def TMinus(T):
    AP = APlus(T)
    result = np.zeros((space.dimension,space.dimension),dtype="complex_")
    for k in range(n):
        for l in range(n):
            result += np.conjugate(AP)[k,l]*space.lowering[k] @ space.lowering[l]
    return sp.expm(result)

# The T0 term in Equation (35). Verified. 
def T0(T):
    AP = APlus(T)
    Azero = A0(AP)
    result = np.zeros((space.dimension,space.dimension),dtype="complex_")
    for k in range(n):
        for l in range(n):
            result += Azero[k,l] * space.raising[k] @ space.lowering[l] - Azero[l,k]*space.lowering[k] @ space.raising[l]
    return sp.expm(result)

# The T+ term in Equation (35). Verified. 
def TPlus(T):
    AP = APlus(T)
    result = np.zeros((space.dimension,space.dimension),dtype="complex_")
    for k in range(n):
        for l in range(n):
            result += AP[k,l]*space.raising[k] @ space.raising[l]
    return sp.expm(result)

# Generalised Wick's theorem for 2-point functions
def genWicks2(M1,M2,a,b):
    deltaM = np.linalg.inv(M1) @ M2
    result = 0
    for i in range(2*n):
        for j in range(2*n):
            result += M2[a,i] * M2[b,j] * buildingBlock2(deltaM,i,j)
    return result 

# Generate a random group element 
def groupElem():
    A = np.random.rand(2*n,2*n)
    A = A - A.T
    M = sp.expm(A)
    return M

# Objective function. This gives us the minimum energy attained by H on the span of |J1> and |J2>. 
def f(a,b,c):
    return 0.5*(a+c-np.sqrt((a+c)**2 - 4*(a*c - np.abs(b)**2)))

# Generalised Wick's theorem for 4-point functions
def genWicks4(M1,M2,a,b,c,d):
    deltaM = np.linalg.inv(M1) @ M2
    result = 0
    for i in range(2*n):
        for j in range(2*n):
            for k in range(2*n):
                for l in range(2*n):
                    result += M2[a,i] * M2[b,j]  * M2[c,k] * M2[d,l] * buildingBlock4(deltaM,i,j,k,l)
    return result 

def x(v):
    output = np.zeros(2*n)
    for a in v:
        output[a] = 1
    return output

def submatrix(A,v):
    s = len(v)
    B = np.zeros((s,s))
    for i in range(s):
        for j in range(s):
            B[i,j] = A[v[i],v[j]]
    return B



vacuumCorrelator = np.zeros((2*n,2*n,2*n,2*n),dtype="complex_")
for i in range(2*n):
    for j in range(2*n):
        for k in range(2*n):
            for l in range(2*n):
                vacuumCorrelator[i,j,k,l] = wicks4(C2(Omega0),i,j,k,l)

M1 = groupElem()
M2 = groupElem()

# Direct calculation <J1|....|J2>
#print(vacuum.T @ U(np.linalg.inv(M1)) @ space.majorana[1] @ space.majorana[2] @ space.majorana[3] @ space.majorana[4] @ U(M2) @ vacuum)

"""starttime = timeit.default_timer()
print(genWicks4(M1,M2,1,2,3,4))
endtime = timeit.default_timer()
print(endtime - starttime)"""


def genWicks4Full(M1,M2,a,b,c,d):
    deltaM = np.linalg.inv(M1) @ M2
    T = cartan(deltaM)[0]
    theta = cartan(deltaM)[2]
    R1 = R(T)
    A = M2 @ R
    result = 0
    for i in range(2*n):
        for j in range(2*n):
            for k in range(2*n):
                for l in range(2*n):
                    buildingBlock = np.zeros((2*n,2*n,2*n,2*n),dtype="complex_")
                    for m in range(2*n):
                        for o in range(2*n):
                            for p in range(2*n):
                                for q in range(2*n):
                                    buildingBlock[i,j,k,l] += R1[i,m] * R1[j,o] * R1[k,p] * R1[l,q] * vacuumCorrelator[m,o,p,q]
                    result += M2[a,i] * M2[b,j]  * M2[c,k] * M2[d,l] * buildingBlock[i,j,k,l]
    return 0.25*r0(T,theta)*result

# A faster version of generalised Wick's theorem for 2-point functions. Verified.
def genWicks2V2(M1,M2,a,b):
    deltaM = np.linalg.inv(M1) @ M2
    T = cartan(deltaM)[0]
    theta = cartan(deltaM)[2]
    R1 = R(T)
    A = M2 @ R1
    result = 0
    for i in range(2*n):
        for j in range(2*n):
            result += A[a,i]*A[b,j]*Omega0[i,j]
    return 0.5j*r0(T,theta)*result

# A faster version of generalised Wick's theorem for 4-point functions. 
def genWicks4V2(M1,M2,a,b,c,d):
    deltaM = np.linalg.inv(M1) @ M2
    T = cartan(deltaM)[0]
    theta = cartan(deltaM)[2]
    R1 = R(T)
    A = M2 @ R1
    result = 0
    for i in range(2*n):
        for j in range(2*n):
            for k in range(2*n):
                for l in range(2*n):
                    result += A[a,i]*A[b,j]*A[c,k]*A[d,l]*vacuumCorrelator[i,j,k,l]
    return r0(T,theta)*result


def xx(x):
    output = np.zeros(2*n)
    for i in x:
        output[i] = 1
    return output

def Jx(xx):
    w = np.linalg.norm(xx,ord=0)
    J = np.zeros((int(w),2*n),dtype="complex_")
    count = 0
    for i in range(2*n):
        if xx[i] == 1:
            J[count,i] = 1
            count += 1
    return J

def Dx(xx):
    output = np.zeros((2*n,2*n))
    for i in range(2*n):
        output[i,i] = 1-xx[i]
    return output 

def Rx(P,Q,x):
    ex = xx(x)
    w = int(np.linalg.norm(ex,ord=0))
    D = Dx(ex)
    J = Jx(ex)
    return np.block([[1j*Omega0,-np.eye(2*n),np.eye(2*n),np.zeros((2*n,w),dtype="complex_")],
                     [np.eye(2*n),1j*P,-np.eye(2*n),np.zeros((2*n,w),dtype="complex_")],
                     [-np.eye(2*n),np.eye(2*n),1j*D @ Q @ D, J.T + 1j*D @ Q @ J.T],
                     [np.zeros((w,2*n),dtype="complex_"),np.zeros((w,2*n),dtype="complex_"),-J + 1j*J @ Q @ D,1j*J @ Q @ J.T]])

def wicksBravyi(P,Q,x):
    return (1j/4)**n * Pf(Rx(P,Q,x)) / (ip(Omega0,P) * ip(Q,Omega0))



"""starttime = timeit.default_timer()
print(genWicks4Full(M1,M2,1,2,3,4))
endtime = timeit.default_timer()
print("Time to compute:",endtime - starttime)

print(vacuum.T @ U(np.linalg.inv(M1)) @ space.majorana[1] @ space.majorana[2] @ space.majorana[3] @ space.majorana[4] @ U(M2) @ vacuum)"""

"""comparison = np.zeros((space.dimension,space.dimension),dtype="complex_")
for i in range(2*n):
    for j in range(2*n):
        for k in range(2*n):
            for l in range(2*n):
                comparison += M1[1,i] * M1[2,j] * M1[3,k] * M1[4,l] * space.majorana[i] @ space.majorana[j] @ space.majorana[k] @ space.majorana[l]

print(np.linalg.norm(space.majorana[1] @ space.majorana[2] @ space.majorana[3] @ space.majorana[4] @ U(M1) -  U(M1) @ comparison))
"""

t = 1
u = 1

# Helps us index the Majorana modes correctly.
def index(j,sigma,k):
    if sigma == "up":
        sigma = 1
    elif sigma == "down":
        sigma = 0
    if k == "q":
        k = 0
    elif k == "p":
        k = 1
    return int(j % (n/2) + sigma*(n/2) + k*n)

# The h1_{ab} matrix which contracts with the Majorana modes to produce the quadratic part of the Hamiltonian
rows = []
columns = []
data = []
for j in range(int(n/2)):
    for sigma in range(2):
        rows += [index(j,sigma,0),index(j,sigma,1),index(j+1,sigma,0),index(j+1,sigma,1)]
        columns += [index(j+1,sigma,1),index(j+1,sigma,0),index(j,sigma,1),index(j,sigma,0)]
        data += [-t,t,-t,t]
h1 = scipy.sparse.csc_array((data,(rows,columns)),shape=(2*n,2*n))

# The h2_{abcd} tensor that produces the quartic part of the Hamiltonian
sparseh2 = []
for k in range(int(n/2)):
    sparseh2 += [
        [index(k,'up','q'),index(k,'up','q'),index(k,'down','q'),index(k,'down','q'),1.0],
        [index(k,'up','q'),index(k,'up','q'),index(k,'down','q'),index(k,'down','p'),1.0j],
        [index(k,'up','q'),index(k,'up','q'),index(k,'down','p'),index(k,'down','q'),-1.0j],
        [index(k,'up','q'),index(k,'up','q'),index(k,'down','p'),index(k,'down','p'),1.0],
        [index(k,'up','q'),index(k,'up','p'),index(k,'down','q'),index(k,'down','q'),1.0j],
        [index(k,'up','q'),index(k,'up','p'),index(k,'down','q'),index(k,'down','p'),-1.0],
        [index(k,'up','q'),index(k,'up','p'),index(k,'down','p'),index(k,'down','q'),1.0],
        [index(k,'up','q'),index(k,'up','p'),index(k,'down','p'),index(k,'down','p'),1.0j],
        [index(k,'up','p'),index(k,'up','q'),index(k,'down','q'),index(k,'down','q'),-1.0j],
        [index(k,'up','p'),index(k,'up','q'),index(k,'down','q'),index(k,'down','p'),1.0],
        [index(k,'up','p'),index(k,'up','q'),index(k,'down','p'),index(k,'down','q'),-1.0],
        [index(k,'up','p'),index(k,'up','q'),index(k,'down','p'),index(k,'down','p'),-1.0j],
        [index(k,'up','p'),index(k,'up','p'),index(k,'down','q'),index(k,'down','q'),1.0],
        [index(k,'up','p'),index(k,'up','p'),index(k,'down','q'),index(k,'down','p'),1.0j],
        [index(k,'up','p'),index(k,'up','p'),index(k,'down','p'),index(k,'down','q'),-1.0j],
        [index(k,'up','p'),index(k,'up','p'),index(k,'down','p'),index(k,'down','p'),1.0]
    ]

# The kinetic energy term of the Hamiltonian. Verified.
H1 = np.zeros((space.dimension,space.dimension),dtype="complex_")
for i in range(2*n):
    for j in range(2*n):
        H1 += 0.5j*h1[i,j] * space.majorana[i] @ space.majorana[j]

# The interaction term of the Hamiltonian. Verified. 
H2 = np.zeros((space.dimension,space.dimension),dtype="complex_")
for row in sparseh2:
    H2 += 0.25*row[4]*space.majorana[row[0]] @ space.majorana[row[1]] @ space.majorana[row[2]] @ space.majorana[row[3]]

def expH(x):
    C = 0.5*(np.eye(2*n)+1.0j*x)
    # Constant shift 
    value = 0
    # Quadratic contribution
    value += 0.25*np.trace(h1 @ x)
    # Quartic contribution
    newpart = 0
    for row in sparseh2:
        a = row[0]; b = row[1]; c = row[2]; d = row[3]; h = row[4]
        newpart += 0.25*h*(C[a][b]*C[c][d] - C[a][c]*C[b][d] + C[a][d]*C[b][c])
    value += newpart 
    return value.real

# Evaluates the expression <J1|H1|J2>. Verified. 
def J1H1J2(M1,M2):
    result = 0
    for i in range(2*n):
        for j in range(2*n):
            result += h1[i,j]*genWicks2V2(M1,M2,i,j)
    return 0.5j*result

# Evaluates the expression <J1|H2|J2>. 
def J1H2J2(M1,M2):
    result = 0
    for row in sparseh2:
        result += row[4]*genWicks4V2(M1,M2,row[0],row[1],row[2],row[3])
    return 0.25*result

def J1HJ2(M1,M2):
    return J1H1J2(M1,M2) + J1H2J2(M1,M2)

def vary(x,K,epsilon):
    return sp.expm(epsilon*K) @ x @ scipy.linalg.expm(epsilon*(K.T))

def randomise(x,epsilon):
    K = np.random.rand(2*n,2*n)
    K = K-K.T
    return vary(x,K,epsilon)

P = np.linalg.inv(M1) @ Omega0 @ M1
Q = np.linalg.inv(M2) @ Omega0 @ M2

a = expH(P)
b = J1HJ2(P,Q)*ip(P,Q)
c = expH(Q)

print(f(a,b,c))
epsilon1 = 1
epsilon2 = 1

for i in range(10):
    flag = 0
    while flag == 0:
        candidate = randomise(P,epsilon1)
        aCandidate = expH(candidate)
        bCandidate = J1HJ2(candidate,Q)*ip(candidate,Q)
        if f(aCandidate,bCandidate,c) < f(a,b,c):
            P = candidate
            a = aCandidate
            b = bCandidate
            flag = 1
        else:
            epsilon1 = epsilon1*0.995

    flag = 0
    while flag == 0:
        candidate = randomise(Q,epsilon2)
        cCandidate = expH(candidate)
        bCandidate = J1HJ2(P,candidate)*ip(P,candidate)
        if f(a,bCandidate,cCandidate) < f(a,b,c):
            P = candidate
            c = cCandidate
            b = bCandidate
            flag = 1
        else:
            epsilon2 = epsilon2*0.995
    print(f(a,b,c),epsilon1,epsilon2)
