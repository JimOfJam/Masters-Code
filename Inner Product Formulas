import numpy as np
import scipy.linalg as sp
import gaussian 

n = 4
rank = 1

Omega0 = np.block([[np.zeros((n,n)),np.eye(n)],[-np.eye(n),np.zeros((n,n))]])
J0 = Omega0 
I = np.eye(2*n)

# Takes the Cartan decomposition of a matrix. Verified.
def cartan(M):
    T = sp.sqrtm(-Omega0 @ M.T @ Omega0 @ M)
    u = T @ np.linalg.inv(M)
    theta = -0.25 * np.trace(Omega0 @ sp.logm(u))
    return [T,u,theta]

# Kronecker delta 
def delta(a,b):
    if a==b:
        return 1
    else:
        return 0

# Converts a matrix to its complex counterpart. Verified.
def cMatrix(K):
    K1 = K[0:n,0:n]
    K2 = K[0:n,n:2*n]
    return K1 + 1j * K2

# Takes the complex determinant of a matrix. Verified
def cDet(K):
    return np.linalg.det(cMatrix(K))

# Executes Equation (82) in the draft paper. Verified.
def IPLucas(K):
    M = sp.expm(K)
    return cDet((M - (J0 @ M @ J0))/2)

# Varies Omega randomly. The larger the value of epsilon, the larger the variation.
def vary(Omega,epsilon):
    K = np.random.rand(2*n,2*n)
    K = K - K.T 
    return sp.expm(epsilon*K) @ Omega @ sp.expm(epsilon*K.T)

# Calculates the matrix A+ defined by Equation (C26)
def APlus(T):
    a = 0.5*sp.tanhm(sp.logm(T))
    return a[0:n,0:n] + 1j * a[0:n,n:2*n]

# Calculates the matrix R in Equation (C29)
def R(T):
    APC = np.conjugate(APlus(T))
    iden = np.eye(n)
    return np.block([[iden-APC,-1j*APC],[-1j*APC,iden+APC]])

# Executes Equation (C31)
def r0(T,theta):
    AP = APlus(T)
    return sp.expm(-1j*theta-np.trace(A0(AP)))

# The 2-point function of a Gaussian state
def C2(M):
    return 0.5*(I + 1j*M)

# Wick's theorem for 4-point functions
def wicks4(C,a,b,c,d):
    return C[a,b]*C[c,d] - C[a,c]*C[b,d] + C[a,d]*C[b,c]

# Building blocks of generalised Wick's theorem for quadratic terms. Verified. 
def buildingBlock2(M,a,b):
    decomp = cartan(M)
    T = decomp[0]
    theta = decomp[2]
    R1 = R(T)
    result = 0
    for i in range(2*n):
        for j in range(2*n):
            result += R1[a,i] * R1[b,j] * Omega0[i,j]
    return 1j*0.5 * r0(T,theta)*result


# Building blocks of generalised Wick's theorem for quartic terms
def buildingBlock4(M,a,b,c,d):
    decomp = cartan(M)
    T = decomp[0]
    theta = decomp[2]
    R1 = R(T)
    C = C2(M)
    result = 0
    for i in range(2*n):
        for j in range(2*n):
            for k in range(2*n):
                for l in range(2*n):
                    result += R1[a,i] * R1[b,j] * R1[c,k] * R1[d,l] * vacuumCorrelator[i,j,k,l]
    return r0(T,theta) * result


space = gaussian.FermionicSpace(n)

# Represents a Lie algebra element in Hilbert space
def hat(X):
    Xhat = np.zeros((space.dimension,space.dimension),dtype="complex_")
    for i in range(2*n):
        for j in range(2*n):
            Xhat += 0.5*X[i,j] * space.majorana[i] @ space.majorana[j]
    return Xhat 

# Equation (C24). Verified. 
def Q(K):
    KPlus = 0.5*(K[0:n,0:n] + 1j * K[0:n,n:2*n])
    result = np.zeros((space.dimension,space.dimension),dtype="complex_")
    for i in range(n):
        for j in range(n):
            result += KPlus[i,j]*space.raising[i]@space.raising[j] + np.conjugate(KPlus[i,j])*space.lowering[i]@space.lowering[j]
    return result 

def A0(AP):
    return 0.25*sp.logm(np.eye(n) - 4 * AP @ np.conjugate(AP))

def expQ(K):
    AP = APlus(sp.expm(K))
    Azero = A0(AP)
    firstterm = np.zeros((space.dimension,space.dimension),dtype="complex_")
    secondterm = firstterm.copy()
    thirdterm = firstterm.copy()
    for k in range(n):
        for l in range(n):
            firstterm += AP[k,l]*space.raising[k] @ space.raising[l]
            secondterm += Azero[k,l] * space.raising[k] @ space.lowering[l] - Azero[l,k]*space.lowering[k]@space.raising[l]
            thirdterm += np.conjugate(AP)[k,l]*space.lowering[k]@space.lowering[l]
    return sp.expm(firstterm) @ sp.expm(secondterm) @ sp.expm(thirdterm)

# Gaussian unitary of a group element connected to identity
def U(g):
    return sp.expm(hat(sp.logm(g)))

# This is the reference state |J0> = |0>
vacuum = np.zeros((2**n,1),dtype="complex_")
vacuum[0,0] = 1


# The T- term in Equation (35). Verified.
def TMinus(T):
    AP = APlus(T)
    result = np.zeros((space.dimension,space.dimension),dtype="complex_")
    for k in range(n):
        for l in range(n):
            result += np.conjugate(AP)[k,l]*space.lowering[k] @ space.lowering[l]
    return sp.expm(result)

# The T0 term in Equation (35). Verified. 
def T0(T):
    AP = APlus(T)
    Azero = A0(AP)
    result = np.zeros((space.dimension,space.dimension),dtype="complex_")
    for k in range(n):
        for l in range(n):
            result += Azero[k,l] * space.raising[k] @ space.lowering[l] - Azero[l,k]*space.lowering[k] @ space.raising[l]
    return sp.expm(result)

# The T+ term in Equation (35). Verified. 
def TPlus(T):
    AP = APlus(T)
    result = np.zeros((space.dimension,space.dimension),dtype="complex_")
    for k in range(n):
        for l in range(n):
            result += AP[k,l]*space.raising[k] @ space.raising[l]
    return sp.expm(result)

# Generalised Wick's theorem for 2-point functions
def genWicks2(M1,M2,a,b):
    deltaM = np.linalg.inv(M1) @ M2
    result = 0
    for i in range(2*n):
        for j in range(2*n):
            result += M2[a,i] * M2[b,j] * buildingBlock2(deltaM,i,j)
    return result 

# Generate a random group element 
def groupElem():
    A = np.random.rand(2*n,2*n)
    A = A - A.T
    M = sp.expm(A)
    return M

# Objective function. This gives us the minimum energy attained by H on the span of |J1> and |J2>. 
def f(a,b,c):
    return 0.5*(a+c-np.sqrt((a+c)**2 - 4*(a*c - np.abs(b)**2)))

# Generalised Wick's theorem for 4-point functions
def genWicks4(M1,M2,a,b,c,d):
    deltaM = np.linalg.inv(M1) @ M2
    result = 0
    for i in range(2*n):
        for j in range(2*n):
            for k in range(2*n):
                for l in range(2*n):
                    result += M2[a,i] * M2[b,j]  * M2[c,k] * M2[d,l] * buildingBlock4(deltaM,i,j,k,l)
    return result 

vacuumCorrelator = np.zeros((2*n,2*n,2*n,2*n),dtype="complex_")
for i in range(2*n):
    for j in range(2*n):
        for k in range(2*n):
            for l in range(2*n):
                vacuumCorrelator[i,j,k,l] = wicks4(Omega0,i,j,k,l)

M1 = groupElem()
M2 = groupElem()
print(vacuum.T @ U(np.linalg.inv(M1)) @ space.majorana[1] @ space.majorana[2] @ space.majorana[3] @ space.majorana[4] @ U(M2) @ vacuum)
print(genWicks4(M1,M2,1,2,3,4))
